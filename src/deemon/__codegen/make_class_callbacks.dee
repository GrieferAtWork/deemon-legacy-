const copyright = "\
/* Copyright (c) 2016 - deemon by Griefer@Work                                    *
 *                                                                                *
 * Permission is hereby granted, free of charge, to any person obtaining a copy   *
 * of this software and associated documentation files (the "Software"), to deal  *
 * in the Software without restriction, including without limitation the rights   *
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      *
 * copies of the Software, and to permit persons to whom the Software is          *
 * furnished to do so, subject to the following conditions:                       *
 *                                                                                *
 * The above copyright notice and this permission notice shall be included in all *
 * copies or substantial portions of the Software.                                *
 *                                                                                *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    *
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  *
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  *
 * SOFTWARE.                                                                      *
 */
";

#include <file>

function open(x): result {
	result = file.io(x,"w");
	result.write(copyright);
	print result: "/" "* Autogenerated file (do not edit) *" "/";
}

f_slt = open("../class/class.operators.inl");

locations = dict {
	"tp_str":     "cs_cast.ctp_str",
	"tp_repr":    "cs_cast.ctp_repr",
	"tp_int32":   "cs_cast.ctp_int32",
	"tp_int64":   "cs_cast.ctp_int64",
	"tp_double":  "cs_cast.ctp_double",
	"tp_call":    "cs_object.ctp_call",
	"tp_not":     "cs_math.ctp_not",
	"tp_bool":    "cs_math.ctp_bool",
	"tp_inv":     "cs_math.ctp_inv",
	"tp_pos":     "cs_math.ctp_pos",
	"tp_neg":     "cs_math.ctp_neg",
	"tp_inc":     "cs_math.ctp_inc",
	"tp_incpost": "cs_math.ctp_incpost",
	"tp_dec":     "cs_math.ctp_dec",
	"tp_decpost": "cs_math.ctp_decpost",
	"tp_add":     "cs_math.ctp_add",
	"tp_iadd":    "cs_math.ctp_iadd",
	"tp_sub":     "cs_math.ctp_sub",
	"tp_isub":    "cs_math.ctp_isub",
	"tp_mul":     "cs_math.ctp_mul",
	"tp_imul":    "cs_math.ctp_imul",
	"tp_div":     "cs_math.ctp_div",
	"tp_idiv":    "cs_math.ctp_idiv",
	"tp_mod":     "cs_math.ctp_mod",
	"tp_imod":    "cs_math.ctp_imod",
	"tp_shl":     "cs_math.ctp_shl",
	"tp_ishl":    "cs_math.ctp_ishl",
	"tp_shr":     "cs_math.ctp_shr",
	"tp_ishr":    "cs_math.ctp_ishr",
	"tp_and":     "cs_math.ctp_and",
	"tp_iand":    "cs_math.ctp_iand",
	"tp_or":      "cs_math.ctp_or",
	"tp_ior":     "cs_math.ctp_ior",
	"tp_xor":     "cs_math.ctp_xor",
	"tp_ixor":    "cs_math.ctp_ixor",
	"tp_pow":     "cs_math.ctp_pow",
	"tp_ipow":    "cs_math.ctp_ipow",
	"tp_hash":    "cs_math.ctp_hash",
	"tp_cmp_lo":  "cs_compare.ctp_cmp_lo",
	"tp_cmp_le":  "cs_compare.ctp_cmp_le",
	"tp_cmp_eq":  "cs_compare.ctp_cmp_eq",
	"tp_cmp_ne":  "cs_compare.ctp_cmp_ne",
	"tp_cmp_gr":  "cs_compare.ctp_cmp_gr",
	"tp_cmp_ge":  "cs_compare.ctp_cmp_ge",
	"tp_seq_get": "cs_seq.ctp_seq_get",
	"tp_seq_del": "cs_seq.ctp_seq_del",
	"tp_seq_set": "cs_seq.ctp_seq_set",
	"tp_seq_size": "cs_seq.ctp_seq_size",
	"tp_seq_contains": "cs_seq.ctp_seq_contains",
	"tp_seq_range_get": "cs_seq.ctp_seq_range_get",
	"tp_seq_range_del": "cs_seq.ctp_seq_range_del",
	"tp_seq_range_set": "cs_seq.ctp_seq_range_set",
	"tp_seq_iter_self": "cs_seq.ctp_seq_iter_self",
};

#define p print f_slt: 
function m(name,retT,params,args,args_inline,more...) {
	local loc = global locations[name];
	local is_object_return = (retT.replace(" ","") == "DeeObject*");
	local err_ret;
	local converter = #more >= 1 ? more[0] : none;
	local fix_args = #more >= 2 ? more[1] : [];
	const err_map = dict {
		"int":        "-1",
		"Dee_hash_t": "(Dee_hash_t)-1",
		"int32_t":    "(int32_t)-1",
		"int64_t":    "(int64_t)-1",
		"double":     "(double)-1.0",
	};
	try err_ret = err_map[retT];
	catch (...) err_ret = "NULL";
	//.(retT,"NULL");
	//switch (retT) {
	//	case "int":        err_ret = "-1"; break;
	//	case "Dee_hash_t": err_ret = "(Dee_hash_t)-1"; break;
	//	case "int32_t":    err_ret = "(int32_t)-1"; break;
	//	case "int64_t":    err_ret = "(int64_t)-1"; break;
	//	case "double":     err_ret = "(double)-1.0"; break;
	//	default:           err_ret = "NULL"; break;
	//}
	if (params) params = ", "+params;
	p "";
	p "// Slot:",name;
	p "static",retT,"_deeinstance_"+name+"(DeeInstanceObject *self"+params+") {";
	//p "static",retT,"_deeinstance_"+name+"_user(DeeInstanceObject *self"+params+") {";
	if (args && !args_inline) {
		if (is_object_return) {
			p " DeeObject *args,*result;";
		} else {
			p " DeeObject *args,*temp;",retT,"result;";
		}
	} else {
		if (!is_object_return) {
			p " DeeObject *temp;",retT,"result;";
		}
	}
	p " DEE_ASSERT(DeeObject_Check(self) && DeeInstance_Check(self));";
	p "#if DEE_CONFIG_RUNTIME_HAVE_CLASS_STATIC_VTABLE";
	p " DEE_ASSERTF(DeeObject_Check(DeeClass_SUFFIX(Dee_TYPE(self))->"+loc+"),\"Missing slot: "+name+"\");";
	p "#endif";
	local fixed_args = "";
	if (args) {
		if (fix_args) {
			for (x: args.split(",")) {
				if (fixed_args) fixed_args += ",";
				if (x in fix_args) {
					fixed_args += (x+"?"+x+":Dee_None");
				} else {
					fixed_args += x;
				}
			}
		} else {
			fixed_args = args;
		}
	}
	function generate_return_code(callback) {
		if (args && !args_inline) {
			p " if ((args = DeeTuple_Pack("+str(fixed_args.count(",")+1)+","+fixed_args+")) == NULL) return "+err_ret+";";
			p " "+(is_object_return ? "result" : "temp")+" = DeeObject_ThisCall("+callback+",(DeeObject *)self,args);";
			p " Dee_DECREF(args);";
			if (is_object_return) {
				p " return result;";
			} else {
				p " if (!temp) return "+err_ret+";";
				if (converter == "ERROR") {
					p " result = temp != NULL;";
				} else if (converter) {
					p " result = "+converter+"(temp);";
				} else {
					p " if (DeeObject_Cast("+retT+",temp,&result) != 0) return "+err_ret+";";
				}
				p " Dee_DECREF(temp);";
				p " return result;";
			}
		} else {
			local used_args = fixed_args ? fixed_args: "Dee_EmptyTuple";
			if (is_object_return) {
				p " return DeeObject_ThisCall("+callback+",(DeeObject *)self,"+used_args+");";
			} else {
				p " if ((temp = DeeObject_ThisCall("+callback+",(DeeObject *)self,"+used_args+")) == NULL) return "+err_ret+";";
				if (converter == "ERROR") {
					p " result = temp != NULL;";
				} else if (converter) {
					p " result = "+converter+"(temp);";
				} else {
					p " if (DeeObject_Cast("+retT+",temp,&result) != 0) return "+err_ret+";";
				}
				p " Dee_DECREF(temp);";
				p " return result;";
			}
		}
	}
	p "#if DEE_CONFIG_RUNTIME_HAVE_CLASS_STATIC_VTABLE";
	generate_return_code("DeeClass_SUFFIX(Dee_TYPE(self))->"+loc);
	p "#else";
	generate_return_code("DeeClassSuffix_GetKnownVirtOperator(DeeClass_SUFFIX(Dee_TYPE(self)),DeeType_SLOT_ID("+name+"))");
	p "#endif";
	p "}";
	//p "static",retT,"_deeinstance_"+name+"_base(DeeInstanceObject *self"+params+") {";
	//if (args && !args_inline) {
	//	if (is_object_return) {
	//		p " DeeObject *callback,*args,*result;";
	//	} else {
	//		p " DeeObject *callback,*args,*temp;",retT,"result;";
	//	}
	//} else {
	//	if (is_object_return) {
	//		p " DeeObject *callback;";
	//	} else {
	//		p " DeeObject *callback,*temp;",retT,"result;";
	//	}
	//}
	//p " DeeClassObject *tp_iter;";
	//p " DEE_ASSERT(!DeeClass_SUFFIX(Dee_TYPE(self))->"+loc+" && \"Slot found in this_t: "+name+"\");";
	//p " DEE_ASSERT(DeeClass_Check(DeeType_BASE(Dee_TYPE(self))) && \"Base isn't a class type\");";
	//p " tp_iter = (DeeClassObject *)DeeType_BASE(Dee_TYPE(self));";
	//p " while ((callback = tp_iter->"+loc+") == NULL) {";
	//p "  tp_iter = (DeeClassObject *)DeeType_BASE(tp_iter);";
	//p "  DEE_ASSERT(DeeClass_Check(tp_iter) && \"Missing slot: "+name+"\");";
	//p " }";
	//generate_return_code("callback");
	//p "}";
}
#undef p

//m("tp_str","DeeObject *","","",false);
//m("tp_repr","DeeObject *","","",false);
//m("tp_int32","int","int32_t *result","result",false);
//m("tp_int64","int","int64_t *result","result",false);
//m("tp_double","int","double *result","result",false);
m("tp_call","DeeObject *","DeeObject *args","args",true);
m("tp_not","DeeObject *","","",false);
m("tp_bool","int","","",false,"DeeObject_Bool");
m("tp_inv","DeeObject *","","",false);
m("tp_pos","DeeObject *","","",false);
m("tp_neg","DeeObject *","","",false);
m("tp_inc","DeeObject *","","",false);
m("tp_incpost","DeeObject *","","",false);
m("tp_dec","DeeObject *","","",false);
m("tp_decpost","DeeObject *","","",false);
m("tp_add","DeeObject *","DeeObject *right","right",false);
m("tp_iadd","DeeObject *","DeeObject *right","right",false);
m("tp_sub","DeeObject *","DeeObject *right","right",false);
m("tp_isub","DeeObject *","DeeObject *right","right",false);
m("tp_mul","DeeObject *","DeeObject *right","right",false);
m("tp_imul","DeeObject *","DeeObject *right","right",false);
m("tp_div","DeeObject *","DeeObject *right","right",false);
m("tp_idiv","DeeObject *","DeeObject *right","right",false);
m("tp_mod","DeeObject *","DeeObject *right","right",false);
m("tp_imod","DeeObject *","DeeObject *right","right",false);
m("tp_shl","DeeObject *","DeeObject *right","right",false);
m("tp_ishl","DeeObject *","DeeObject *right","right",false);
m("tp_shr","DeeObject *","DeeObject *right","right",false);
m("tp_ishr","DeeObject *","DeeObject *right","right",false);
m("tp_and","DeeObject *","DeeObject *right","right",false);
m("tp_iand","DeeObject *","DeeObject *right","right",false);
m("tp_or","DeeObject *","DeeObject *right","right",false);
m("tp_ior","DeeObject *","DeeObject *right","right",false);
m("tp_xor","DeeObject *","DeeObject *right","right",false);
m("tp_ixor","DeeObject *","DeeObject *right","right",false);
m("tp_pow","DeeObject *","DeeObject *right","right",false);
m("tp_ipow","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_lo","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_le","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_eq","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_ne","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_gr","DeeObject *","DeeObject *right","right",false);
m("tp_cmp_ge","DeeObject *","DeeObject *right","right",false);
m("tp_seq_get","DeeObject *","DeeObject *i","i",false);
m("tp_seq_del","int","DeeObject *i","i",false,"ERROR");
m("tp_seq_set","int","DeeObject *i, DeeObject *v","i,v",false,"ERROR");
m("tp_seq_size","DeeObject *","","",false);
m("tp_seq_contains","DeeObject *","DeeObject *elem","elem",false);
m("tp_seq_range_get","DeeObject *","DeeObject *lo, DeeObject *hi","lo,hi",false,none,["lo","hi"]);
m("tp_seq_range_del","int","DeeObject *lo, DeeObject *hi","lo,hi",false,"ERROR",["lo","hi"]);
m("tp_seq_range_set","int","DeeObject *lo, DeeObject *hi, DeeObject *v","lo,hi,v",false,"ERROR",["lo","hi"]);
m("tp_seq_iter_self","DeeObject *","","",false);

















